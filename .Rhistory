install.packages("swirl")
install.packages("jsonlite")
install.packages("Rcmdr")
library(rcmdr)
install.packages("swirl")
library(swirl)
install.packages("Rcmdr")
library(swirl)
swirl()
1
swirl()
z <- 5
while(z >= 3 && z <=10) {}
while(z >= 3 && z <=10) {}
add2 <- function(x, y) {
x + y
}
add2(3, 5)
x <- 1:20
above(x, 12)
source('~/.active-rstudio-document', echo=TRUE)
above(x, 12)
source('~/.active-rstudio-document', echo=TRUE)
above(x)
source('~/.active-rstudio-document', echo=TRUE)
columnmeans(airquality)
columnmean(airquality)
source('~/.active-rstudio-document', echo=TRUE)
columnmean(airquality)
source('~/.active-rstudio-document', echo=TRUE)
columnmean(airquality)
source('~/.active-rstudio-document', echo=TRUE)
columnmean(airquality)
columnmean(airquality, FALSE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document')
columnmean(airquality)
data
dataset()
data()
columnmean(airquality, AirPassengers, BJsales, BOD, CO2)
columnmean(ChickWeight)
summary(DNase)
columnmean(DNase)
summary(data())
columnmean(trees)
data(package - .packages(all.available = TRUE))
data(package = .packages(all.available = TRUE))
columnmean(UN)
data(UN)
USPop
UN
x <- list(a=1:5, b = rnorm(10))
lapply(x, mean)
x <- list(a = 1:4, b = rnorm(10), c = rnorm(20, 1), d = rnorm(100, 5))
lapply(x, mean)
lapply(x, mean)
lapply(x, mean)
lapply(y, mean)
y <- list(a = 1:4, b = rnorm(10), c = rnorm(20, 1), d = rnorm(100, 5))
y <- list(a = 1:4, b = rnorm(10), c = rnorm(20, 1), d = rnorm(100, 5))
lapply(y, mean)
lapply(y, mean)
lapply(y, mean)
sapply(y, mean)
mean(y)
library(swirl)
swirl()
tail(flags)
head(flags)
dim(flags)
class(flags)
cls_list <- lapply(flags, class)
cls_list
class(cls_list)
as.character(cls_list)
cls_vect <- sapply(flags, class)
cls_vect
class(cls_vect)
View(flags)
sum(flags$organge)
sum(flags$orange)
flag_colors <- flags[, 11:17]
head(flag_colors)
lapply(flag_colors, sum)
sapply(flag_colors, sum)
sapply(flag_colors, mean)
flag_shapes <- flags[, 19:23]
lappy(flag_shapes, range)
lapply(flag_shapes, range)
sapply(flag_shapes, range)
shape_mat <- sapply(flag_shapes, range)
shape_mat
class(shape_mat)
unique(c(3, 4, 5, 5, 5, 6, 6))
lapply(unique(c(3, 4, 5, 5, 5, 6, 6)))
lapply(unique(c(flags)
unique_vals <- lapply(unique(c(flags)
)
unique_vals <- lapply(unique(c(flags))
unique_vals <- lapply(unique(c(flags)))
unique_vals <- lapply(unique(flags))
unique_vals <- lapply(unique(flags[, 1:30]))
unique_vals <- lapply(unique(flags))
unique_vals <- lapply(unique(c(flags)))
unique_vals <- lapply(flags, unique)
unique_vals
sapply(unique_vals)
length(unique_vals)
sapply(unique_vals, length)
sapply(flags, unique)
lapply(unique_vals, function(elem) elem[2])
ls()
class(plants)
dim(plants)
nrow(plants)
ncol(plants)
object.size(plants)
names(pants)
names(plants)
head(plants)
head(plants, 1:10)
head(plants[1:10])
head(plants, 10)
tail(plants)
tail(plants, 15)
summary(plants)
sapply(summary(plants))
table(plants$Actie_Growth_Period)
table(plants$Active_Growth_Period)
str(plants)
sapply(flags, unique)
vapply(flags, unique, numeric(1))
ok()
sapply(flags, class)
vapply(flags, class, character(1))
?tapply
table(flags?landmass)
table(flags$landmass)
table(flags$animate)
tapply(flags$animate, flags$landmass, mean)
tapply(flags$population, flags$red, mean)
tapply(flags$population, flags$red, summary)
tapply(flags$landmasses, flags$red, summary)
tapply(flags$landmasses, flags$landmasses, summary)
tapply(flags$landmasses, flags$landmasses, flags$landmasses, summary)
tapply(flags$landmasses, flags$landmass, summary)
tapply(flags$population, flags$red, flags$landmass, summary)
tapply(flags$population, flags$landmass, summary)
setwd("~/ProgrammingAssignment2")
## Two functions used for Caching the Inverse of a Matrix
## This function creates a special "matrix" object that can cache its inverse
makeCacheMatrix <- function(x = matrix()) {
i <- NULL
## sets matrix (i = inverse property; m = matrix)
set <- function( m ) {
x <<- m
i <<- NULL
}
## gets the matrix
get <- function() x
## set the inverse of the matrix
setInverse <- function(inverse) i <<- inverse
## get the inverse of the matrix
getInverse <- function() i
list(set = set, get = get,
setInverse = setInverse,
getInverse = getInverse)
}
## retrieves the inverse if already calculated
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getInverse()
## returns already set inerse
if( !is.null(m) ) {
message("getting cached data")
return(m)
}
## gets matrix
data <- x$get()
## inverse matrix calculation
m <- solve(data) %*% data
## sets inverse for our object
x$setInverse(m)
## Return the matrix
m
}
## Two functions used for Caching the Inverse of a Matrix
## This function creates a special "matrix" object that can cache its inverse
makeCacheMatrix <- function(x = matrix()) {
i <- NULL
## sets matrix (i = inverse property; m = matrix)
set <- function( m ) {
x <<- m
i <<- NULL
}
## gets the matrix
get <- function() x
## set the inverse of the matrix
setInverse <- function(inverse) i <<- inverse
## get the inverse of the matrix
getInverse <- function() i
list(set = set, get = get,
setInverse = setInverse,
getInverse = getInverse)
}
## retrieves the inverse if already calculated
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getInverse()
## returns already set inerse
if( !is.null(m) ) {
message("getting cached data")
return(m)
}
## gets matrix
data <- x$get()
## inverse matrix calculation
m <- solve(data) %*% data
## sets inverse for our object
x$setInverse(m)
## matrix is returned
m
}
## Two functions used for caching the Inverse of a Matrix
## This function creates a special "matrix" object that can cache its inverse
makeCacheMatrix <- function(x = matrix()) {
i <- NULL
## sets matrix (i = inverse property; m = matrix)
set <- function( m ) {
x <<- m
i <<- NULL
}
## gets the matrix
get <- function() x
## set the inverse of the matrix
setInverse <- function(inverse) i <<- inverse
## get the inverse of the matrix
getInverse <- function() i
list(set = set, get = get,
setInverse = setInverse,
getInverse = getInverse)
}
## retrieves the inverse if already calculated
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getInverse()
## returns already set inerse
if( !is.null(m) ) {
message("getting cached data")
return(m)
}
## gets matrix
data <- x$get()
## inverse matrix calculation
m <- solve(data) %*% data
## sets inverse for our object
x$setInverse(m)
## matrix is returned
m
}
